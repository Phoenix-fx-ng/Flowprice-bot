import telebot
from flask import Flask, request
import threading
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
import time

# === 1. Telegram Bot Setup ===
TOKEN = "8020705531:AAHK3wd4a46OeKfZXWYdWafXBTbd5I2bZSE"
bot = telebot.TeleBot(TOKEN)
user_langs = {}
user_access = {}  # Tracks usage
admin_ids = [561234567]  # <-- Replace with your real Telegram ID

ACCESS_LIMIT_DAYS = 3
ACCESS_LIMIT_SIGNALS = 3

# === 2. Trial & Premium Access Check ===
def is_allowed(cid):
    now = time.time()
    user = user_access.get(cid)

    if user and user.get("premium", False):
        return True

    if not user:
        user_access[cid] = {'start_time': now, 'count': 1, 'premium': False, 'notified': False}
        return True

    elapsed_days = (now - user['start_time']) / (60 * 60 * 24)
    if elapsed_days <= ACCESS_LIMIT_DAYS and user['count'] < ACCESS_LIMIT_SIGNALS:
        user['count'] += 1
        if user['count'] == ACCESS_LIMIT_SIGNALS or int(elapsed_days) >= ACCESS_LIMIT_DAYS - 1:
            if not user.get("notified"):
                bot.send_message(cid, "‚ö†Ô∏è *Reminder:* You have only 1 signal or 1 day left in your trial.", parse_mode='Markdown')
                user['notified'] = True
        return True
    return False

# === 3. Language Support ===
languages = {
    "en": "üá¨üáß English",
    "ar": "üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©",
    "fr": "üá´üá∑ Fran√ßais"
}

translations = {
    "welcome": {
        "en": "üü¢ *Welcome to ChartLess Trading Bot‚Ñ¢!*",
        "ar": "üü¢ *ŸÖÿ±ÿ≠ÿ®Ÿãÿß ÿ®ŸÉ ŸÅŸä ÿ®Ÿàÿ™ ÿ¥ÿßÿ±ÿ™-ŸÑÿ≥ ŸÑŸÑÿ™ÿØÿßŸàŸÑ‚Ñ¢!*",
        "fr": "üü¢ *Bienvenue sur le bot de trading ChartLess‚Ñ¢ !*"
    },
    "send_format": {
        "en": "*Send your data in this format:*\n`Instrument, High, Low, Current`",
        "ar": "*ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®Ÿáÿ∞ÿß ÿßŸÑÿ¥ŸÉŸÑ:*\n`ÿßŸÑÿ£ÿØÿßÿ©ÿå ÿßŸÑÿ£ÿπŸÑŸâÿå ÿßŸÑÿ£ÿØŸÜŸâÿå ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ≠ÿßŸÑŸä`",
        "fr": "*Envoyez vos donn√©es dans ce format :*\n`Instrument, Haut, Bas, Actuel`"
    },
    "choose_lang": {
        "en": "üåê *Please select your language:*",
        "ar": "üåê *ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ ÿßÿÆÿ™ÿ± ŸÑÿ∫ÿ™ŸÉ:*",
        "fr": "üåê *Veuillez s√©lectionner votre langue :*"
    },
    "phase_selected": {
        "en": "‚úÖ *{phase} selected.* Now send: `instrument, high, low, current`\n_(e.g. Phase 1: 29th‚Äì2nd)_",
        "ar": "‚úÖ *{phase} ÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ±Ÿá.* ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ: `ÿßŸÑÿ£ÿØÿßÿ©ÿå ÿßŸÑÿ£ÿπŸÑŸâÿå ÿßŸÑÿ£ÿØŸÜŸâÿå ÿßŸÑÿ≠ÿßŸÑŸä`\n_(ŸÖÿ´ÿßŸÑ: ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© 1 ŸÖŸÜ 29 ÿ•ŸÑŸâ 2)_",
        "fr": "‚úÖ *{phase} s√©lectionn√©e.* Envoyez maintenant : `instrument, haut, bas, actuel`\n_(ex : Phase 1 : 29 √† 2)_"
    },
    "error_format": {
        "en": "‚ö†Ô∏è Error: Please send like: `instrument, high, low, current`",
        "ar": "‚ö†Ô∏è ÿÆÿ∑ÿ£: ÿ£ÿ±ÿ≥ŸÑ ŸÖÿ´ŸÑ Ÿáÿ∞ÿß: `ÿßŸÑÿ£ÿØÿßÿ©ÿå ÿßŸÑÿ£ÿπŸÑŸâÿå ÿßŸÑÿ£ÿØŸÜŸâÿå ÿßŸÑÿ≠ÿßŸÑŸä`",
        "fr": "‚ö†Ô∏è Erreur : Envoyez comme ceci : `instrument, haut, bas, actuel`"
    },
    "not_found": {
        "en": "‚ö†Ô∏è Error: Instrument not found.",
        "ar": "‚ö†Ô∏è ÿÆÿ∑ÿ£: ÿßŸÑÿ£ÿØÿßÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©.",
        "fr": "‚ö†Ô∏è Erreur : Instrument introuvable."
    }
}

def t(key, cid):
    lang = user_langs.get(cid, "en")
    return translations[key].get(lang, translations[key]["en"])

# === 4. Instruments & Gaps ===
instrument_data = {
    "gold": {"tp": 40, "sl": 13.33, "icon": "ü•á"},
    "audjpy": {"tp": 2, "sl": 0.67, "icon": "üá¶üá∫/üáØüáµ"},
    "gbpusd": {"tp": 0.02, "sl": 0.0067, "icon": "üá¨üáß/üá∫üá∏"},
    "nasdaq": {"tp": 600, "sl": 200, "icon": "üìä"},
    "eurusd": {"tp": 0.017, "sl": 0.0057, "icon": "üá™üá∫/üá∫üá∏"},
    "silver": {"tp": 1.5, "sl": 0.5, "icon": "ü•à"},
    "crudeoil": {"tp": 6, "sl": 2, "icon": "üìÇ"},
    "usdchf": {"tp": 0.01, "sl": 0.0033, "icon": "üá∫üá∏/üá®üá≠"},
    "usdjpy": {"tp": 1.8, "sl": 0.6, "icon": "üá∫üá∏/üáØüáµ"},
    "s&p500": {"tp": 125, "sl": 41.67, "icon": "üìà"},
    "gbpjpy": {"tp": 3, "sl": 1, "icon": "üá¨üáß/üáØüáµ"},
    "eurgbp": {"tp": 0.015, "sl": 0.005, "icon": "üá™üá∫/üá¨üáß"},
    "btc": {"tp": 1200, "sl": 400, "icon": "‚Çø"},
}

# === 5. Start Menu ===
@bot.message_handler(commands=['start'])
def start(message):
    cid = message.chat.id
    markup = InlineKeyboardMarkup()
    for code, name in languages.items():
        markup.add(InlineKeyboardButton(name, callback_data=f"lang_{code}"))
    bot.send_message(cid, t("choose_lang", cid), parse_mode='Markdown', reply_markup=markup)

@bot.callback_query_handler(func=lambda call: True)
def callback_menu(call):
    cid = call.message.chat.id
    data = call.data

    if data.startswith("lang_"):
        user_langs[cid] = data.split("_")[1]
        welcome(call.message)

    elif data in ["phase1", "phase2"]:
        bot.send_message(cid, t("phase_selected", cid).format(phase=data.upper()), parse_mode='Markdown')

    elif data == "info":
        info = "üìò *ChartLess Strategy‚Ñ¢ Info:*\n_This strategy is based on phase-based structure, TP/SL gap logic, and backup recovery zone. It helps you trade with structure, not noise._"
        back = InlineKeyboardMarkup().add(InlineKeyboardButton("üîô Back", callback_data='back'))
        bot.edit_message_text(info, cid, call.message.message_id, parse_mode='Markdown', reply_markup=back)

    elif data == "list":
        instruments = "\n".join(f"‚Äì {v['icon']} {k.upper()}" for k, v in instrument_data.items())
        back = InlineKeyboardMarkup().add(InlineKeyboardButton("üîô Back", callback_data='back'))
        bot.edit_message_text(f"üìä *Available Instruments:*\n{instruments}", cid, call.message.message_id, parse_mode='Markdown', reply_markup=back)

    elif data == "usage":
        usage(call.message)

    elif data == "back":
        welcome(call.message)

def welcome(message):
    cid = message.chat.id
    markup = InlineKeyboardMarkup()
    markup.row(
        InlineKeyboardButton("üìò Strategy Info", callback_data='info'),
        InlineKeyboardButton("üìä Instruments", callback_data='list')
    )
    markup.row(
        InlineKeyboardButton("üßÆ View Your Usage", callback_data='usage'),
        InlineKeyboardButton("üåÄ Phase 1", callback_data='phase1'),
        InlineKeyboardButton("üîÅ Phase 2", callback_data='phase2')
    )
    markup.row(
        InlineKeyboardButton("üìû Contact Admin", url="https://t.me/PhoenixFx001")
    )
    bot.send_message(cid, t("welcome", cid) + "\n\n" + t("send_format", cid), parse_mode='Markdown', reply_markup=markup)

# === 6. Signal Logic ===
@bot.message_handler(func=lambda m: True)
def handle(message):
    cid = message.chat.id
    if not is_allowed(cid):
        bot.reply_to(message, "üîí *Trial ended.* You‚Äôve used 3 signals or 3 days.\nTo unlock full access, contact admin: @PhoenixFx001", parse_mode='Markdown')
        return

    try:
        parts = [x.strip().lower() for x in message.text.strip().split(",")]
        if len(parts) != 4:
            raise ValueError(t("error_format", cid))

        inst, high, low, curr = parts[0], float(parts[1]), float(parts[2]), float(parts[3])
        if inst not in instrument_data:
            raise ValueError(t("not_found", cid))

        tp_gap = instrument_data[inst]["tp"]
        sl_gap = instrument_data[inst]["sl"]
        entry = round((high + low + curr) / 3, 4)
        direction = "Buy" if curr > entry else "Sell"
        quote = "_‚ÄúDiscipline is the bridge between goals and trading success.‚Äù_"

        if direction == "Buy":
            tp = round(entry + tp_gap, 4)
            sl = round(entry - sl_gap, 4)
            backup = round(high + sl_gap, 4)
            entry_zone = f"`{round(entry - sl_gap, 4)} ‚ûî {entry}`"
            status = "üü¢ *Entry Valid*" if curr >= (entry - sl_gap) else "‚è≥ *Waiting for Entry Zone*"
        else:
            tp = round(entry - tp_gap, 4)
            sl = round(entry + sl_gap, 4)
            backup = round(low - sl_gap, 4)
            entry_zone = f"`{entry} ‚ûî {round(entry + sl_gap, 4)}`"
            status = "üü¢ *Entry Valid*" if curr <= (entry + sl_gap) else "‚è≥ *Waiting for Entry Zone*"

        rr = round(tp_gap / sl_gap, 2)
        icon = instrument_data[inst]["icon"]

        msg = f"""
{icon} *ChartLess Strategy ‚Äì {inst.upper()}*

üîπ *Entry Price:* `{entry}`
üîπ *Direction:* *`{direction}`*
üìÖ *Entry Zone:* {entry_zone}
{status}

üåü *TP:* `{tp}`
üõ° *SL:* `{sl}`
‚öñÔ∏è *R:R:* *`1:{rr}`*

üîÅ *Backup Entry:* `{backup}` (same direction)

üß† *Logic:* _Entry valid within 48hrs. If SL hits, re-enter if price returns in 3 days._

üí¨ {quote}
*_By Phoenix FX ‚Äì ChartLess Trading‚Ñ¢_*
"""
        bot.reply_to(message, msg, parse_mode='Markdown')

    except Exception as e:
        bot.reply_to(message, str(e))

# === 7. /usage & /approve ===
@bot.message_handler(commands=['usage'])
def usage(message):
    cid = message.chat.id
    user = user_access.get(cid)
    if not user:
        bot.reply_to(message, "üßÆ No usage data yet. Start by using a signal.")
        return

    days_used = (time.time() - user['start_time']) / (60 * 60 * 24)
    days_left = max(0, ACCESS_LIMIT_DAYS - int(days_used))
    signals_left = max(0, ACCESS_LIMIT_SIGNALS - user['count'])
    status = "‚úÖ Premium User" if user.get("premium") else "üß™ Trial User"

    bot.reply_to(message, f"""
üßÆ *Your Usage Summary:*
‚Ä¢ Status: {status}
‚Ä¢ Signals left: `{signals_left}`
‚Ä¢ Days left: `{days_left}`

üîë To unlock Premium, contact @PhoenixFx001
""", parse_mode='Markdown')

@bot.message_handler(commands=['approve'])
def approve_user(message):
    cid = message.chat.id
    if cid not in admin_ids:
        bot.reply_to(message, "‚õîÔ∏è You‚Äôre not allowed to use this command.")
        return

    try:
        parts = message.text.strip().split()
        if len(parts) != 2:
            raise Exception("Usage: /approve USER_ID")

        target = int(parts[1])
        user_access[target] = user_access.get(target, {})
        user_access[target].update({'premium': True, 'start_time': 0, 'count': 0, 'notified': False})
        bot.reply_to(message, f"‚úÖ User {target} is now Premium.")
        bot.send_message(target, "üéâ You have been granted *Premium Access!* Enjoy unlimited usage.", parse_mode='Markdown')
    except Exception as e:
        bot.reply_to(message, f"Error: {str(e)}")

# === 8. Flask Web Server ===
app = Flask('')
@app.route('/')
def home():
    return "ChartLess Bot is alive!"

@app.route('/' + TOKEN, methods=['POST'])
def getMessage():
    bot.process_new_updates([telebot.types.Update.de_json(request.stream.read().decode("utf-8"))])
    return "OK", 200

def run(): app.run(host='0.0.0.0', port=8080)
def keep_alive(): threading.Thread(target=run).start()

# === 9. Launch ===
keep_alive()
bot.infinity_polling()
